# Очереди и множества (Queue и Set)

Кроме стандартного хранения ключей и значений в виде отображения (map), DataGrid обеспечивает реализацию быстрой распределенной блокирующей очереди (Distributed Blocking Queue) и распределенного множества (Distributed Set).

В DataGrid есть интерфейсы `IgniteQueue` и `IgniteSet`, которые наследуют `java.util.concurrent.BlockingQueue` и `java.util.Set` соответственно. DataGrid также поддерживает все операции интерфейса `java.util.Collection`. `IgniteQueue` и `IgniteSet` можно создать в режиме коллокации или без нее.

Ниже описаны примеры создания распределенных очереди и множества.

Создание распределенной очереди:

:::{code-block} java
:caption: Java
Ignite ignite = Ignition.start();

IgniteQueue<String> queue = ignite.queue("queueName", // Название очереди.
        0, // Емкость очереди. `0` — неограниченная очередь.
        new CollectionConfiguration() // Конфигурация коллекции.
);
:::

Создание распределенного множества:

:::{code-block} java
:caption: Java
Ignite ignite = Ignition.start();

IgniteSet<String> set = ignite.set("setName", // Название множества.
        new CollectionConfiguration() // Конфигурация коллекции.
);
:::

## Коллоцированый и неколлоцированый режимы

Если требуется небольшое количество очередей или множеств с большим объемом данных, создавайте их в режиме без коллокации. В нем примерно равные части каждой очереди или множества хранятся на каждом узле кластера.

Если требуется много очередей или множеств относительно небольшого размера (по сравнению с общим объемом кешей), их лучше создавать в режиме с коллокацией. В нем все элементы очереди или множества сохраняются на одном узле кластера и примерно одинаковое количество очередей/множеств назначается каждому узлу.

Режим без коллокации стоит использовать только для `PARTITIONED`-кешей, так как этот режим поддерживается только ими.

Чтобы создать коллоцированные очередь или множество, установите свойство `collocated` в `CollectionConfiguration`.

Создание коллоцированной очереди:

:::{code-block} java
:caption: Java
Ignite ignite = Ignition.start();

CollectionConfiguration colCfg = new CollectionConfiguration();

colCfg.setCollocated(true);

// Создайте коллоцированную очередь.
IgniteQueue<String> queue = ignite.queue("queueName", 0, colCfg);
:::

Создание коллоцированного множества:

:::{code-block} java
:caption: Java
Ignite ignite = Ignition.start();

CollectionConfiguration colCfg = new CollectionConfiguration();

colCfg.setCollocated(true);

// Создайте коллоцированное множество.
IgniteSet<String> set = ignite.set("setName", colCfg);
:::

## Очереди кеширования (Cache Queues) и балансировка нагрузки

Элементы очереди остаются в ней до тех пор, пока кто-нибудь их не заберет, при этом один и тот же элемент никогда не попадает на два разных узла. В DataGrid очередь кеша можно использовать в качестве альтернативного подхода распределения заданий и балансировки нагрузки.

С помощью потоков на удаленных узлах можно добавлять в очередь вычисления, например экземпляры `IgniteRunnable`, и вызывать метод `IgniteQueue.take()`. Если очередь пустая, метод заблокируется. Если метод `take()` вернет задание, поток обработает его и снова вызовет `take()` для получения следующего задания. Потоки на удаленных узлах начнут выполнять следующее задание только после завершения предыдущего. Это позволяет создать идеально сбалансированная систему, в которой каждый узел берет только такое количество заданий, которое он может обработать.

## Настройки коллекции

Коллекции DataGrid можно настроить в API через `CollectionConfiguration` (подробнее написано в примерах выше).

Доступные параметры настройки:

| Setter | Описание | Значение по умолчанию |
|---|---|---|
| `setCollocated(boolean)` | Устанавливает режим коллокации | `false` |
| `setCacheMode(CacheMode)` | Устанавливает режим кеширования: `PARTITIONED`, `REPLICATED` или `LOCAL` | `PARTITIONED` |
| `setAtomicityMode(CacheAtomicityMode)` | Устанавливает режим атомарности кеша: `ATOMIC` или `TRANSACTIONAL` | `ATOMIC` |
| `setOffHeapMaxMemory(long)` | Устанавливает максимальный размер памяти вне heap (Off-Heap) | `0` (без ограничений) |
| `setBackups(int)` | Устанавливает количество резервных копий | `0` |
| `setNodeFilter(IgnitePredicate<ClusterNode>)` | Необязательный предикат. Указывает, на каких узлах должны храниться записи | — |