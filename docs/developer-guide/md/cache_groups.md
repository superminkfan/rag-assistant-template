# Кеш-группы

Каждый кеш в кластере использует его ресурсы: кеш разделен на партиции, состояние которых нужно отслеживать на каждом узле.

При включенном Native Persistence (подробнее о нем написано в подразделе [«Персистентность DataGrid»](datagrid_persistence.md) раздела «Настройка Persistence») для каждой партиции на диске создается открытый файл, который DataGrid активно использует для чтения, записи и вычитки данных. Чем больше кешей и партиций:

- Тем больше Java Heap занят информацией о распределении партиций (partition map). У каждого кеша есть собственные распределение и карта партиций.
- Тем больше времени может потребоваться для присоединения нового узла к кластеру.
- Тем больше времени может потребоваться для инициирования ребалансировки, если узел покинет кластер.
- Тем больше файлов партиций остаются открытыми и тем хуже может стать производительность процесса копирования «грязных» страниц из оперативной памяти в файлы партиций на диске (процесс checkpointing). «Грязная» страница — страница, которая обновилась в оперативной памяти, но не записалась в соответствующий файл партиций (обновление было добавлено только в WAL). Подробнее о процессе checkpointing написано в подразделе [«Персистентность DataGrid»](datagrid_persistence.md) раздела «Настройка Persistence».

:::{admonition} Внимание
:class: danger

При развертывании кластера с несколькими сотнями кешей эти проблемы не будут заметны. Но если в кластере тысячи кешей, эти проблемы могут повлиять на его работу.
:::

Чтобы снизить вероятность возникновения таких проблем при большом количестве кешей, используйте кеш-группы. У кешей в одной группе одинаковые внутренние структуры, например карты партиций. Кеш-группы ускоряют обработку событий топологии и снижают общее использование памяти. С точки зрения API нет разницы, является ли кеш частью группы или нет.

Чтобы объединить кеши в группы, установите свойство `groupName` в `CacheConfiguration`.

::::{md-tab-set}
:::{md-tab-item} XML
```xml
<bean class="org.apache.ignite.configuration.IgniteConfiguration">
    <property name="cacheConfiguration">
        <list>
            <!-- Партицированный кеш для данных `Person`. -->
            <bean class="org.apache.ignite.configuration.CacheConfiguration">
                <property name="name" value="Person"/>
                <property name="backups" value="1"/>
                <!-- Создание кеш-группы. -->
                <property name="groupName" value="group1"/>
            </bean>
            <!-- Партицированный кеш для данных `Organization`. -->
            <bean class="org.apache.ignite.configuration.CacheConfiguration">
                <property name="name" value="Organization"/>
                <property name="backups" value="1"/>
                <!-- Создание кеш-группы. -->
                <property name="groupName" value="group1"/>
            </bean>
        </list>
    </property>
</bean>
```
:::

:::{md-tab-item} Java
```java
// Определение конфигурации кластера.
IgniteConfiguration cfg = new IgniteConfiguration();

// Определение конфигурации кеша `Person`.
CacheConfiguration<Integer, Person> personCfg = new CacheConfiguration<Integer, Person>("Person");

personCfg.setBackups(1);

// Создание кеш-группы.
personCfg.setGroupName("group1");

// Определение конфигурации кеша `Organization`.
CacheConfiguration orgCfg = new CacheConfiguration("Organization");

orgCfg.setBackups(1);

// Создание кеш-группы.
orgCfg.setGroupName("group1");

cfg.setCacheConfiguration(personCfg, orgCfg);

// Запуск узла.
Ignition.start(cfg);
```
:::

:::{md-tab-item} С#/.NET
```c#
var cfg = new IgniteConfiguration
{
    CacheConfiguration = new[]
    {
        new CacheConfiguration
        {
            Name = "Person",
            Backups = 1,
            GroupName = "group1"
        },
        new CacheConfiguration
        {
            Name = "Organization",
            Backups = 1,
            GroupName = "group1"
        }
    }
};
Ignition.Start(cfg);
```
:::
::::

В примере выше кеши `Person` и `Organization` принадлежат кеш-группе `group1`.

:::{admonition} Как различаются пары «ключ-значение»?
:class: hint

Если кеш назначается в кеш-группу, его данные хранятся в общих для всех кешей группы структурах партиции. При добавлении в кеш каждый ключ получает уникальный идентификатор кеша, которому он принадлежит. Идентификатор автоматически формируется из названия кеша; это позволяет хранить данные разных кешей в одних и тех же партициях и структурах B+ дерева.
:::

Главный аргумент для использования группировки: при создании группы из 1000 кешей понадобится в 1000 раз меньше внутренних структур для хранения данных, карт и открытых файлов партиций.

:::{admonition} Нужно ли постоянно использовать кеш-группы?
:class: hint

У кеш-групп много преимуществ, но они также могут повлиять на производительность поиска индексов и операций чтения. Все данные и индексы перемешиваются в общих структурах данных (картах партиций и структурах B+ дерева), и операции запроса данных требуют больше времени.

Один из возможных сценариев — использовать кеш-группы для кластеров из десятков или сотен узлов и большим числом кешей, если в них обнаружено:

- увеличение использования Java Heap внутренними структурами;
- падение производительности операций `checkpointing`;
- медленное присоединение узла к кластеру.
:::