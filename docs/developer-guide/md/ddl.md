# DDL-команды

В данном разделе перечислены все команды DDL (Data Definition Language, язык определения данных), которые поддерживает Platform V DataGrid.

## CREATE TABLE

Команда `CREATE TABLE` создает новый кеш DataGrid и соответствующую ему SQL-таблицу. Основной кеш хранит данные в формате «ключ-значение», а таблица предоставляет возможность работы с этими данными с помощью SQL-запросов.

Таблица размещается в указанной в параметрах подключения схеме. Если схема не указана, по умолчанию используется схема `PUBLIC`.

Команда `CREATE TABLE` выполняется синхронно. Она блокирует выполнение других DDL-команд, пока ее выполнение не завершится. Команды DML (Data Manipulation Language, язык манипулирования данными) могут выполняться одновременно и не блокируются.

:::{code-block} sql
:caption: SQL
CREATE TABLE [IF NOT EXISTS] tableName (tableColumn [, tableColumn]...
[, PRIMARY KEY (columnName [,columnName]...)])
[WITH "paramName=paramValue [,paramName=paramValue]..."]
 
tableColumn := columnName columnType [DEFAULT defaultValue] [PRIMARY KEY]
:::

**Параметры команды `CREATE TABLE`:**

- `tableName` — имя создаваемой таблицы.
- `tableColumn` — имя и тип столбца, который будет добавлен в новую таблицу.
- `columnName` — имя уже существующего столбца.
- `DEFAULT` устанавливает значение по умолчанию для столбца. Допускаются только константные значения.
- `IF NOT EXISTS` создает таблицу в случае, если таблицы с указанным именем еще не существует.
- `PRIMARY KEY` определяет первичный ключ для таблицы, который может включать один или несколько столбцов.
- `WITH` принимает дополнительные параметры, которые не предусмотрены стандартом `SQL ANSI-99`:
   - `TEMPLATE=<name of cache's template>` — чувствительное к регистру имя шаблона кеша. Шаблоном является экземпляр класса `CacheConfiguration`, который зарегистрирован с помощью метода `Ignite.addCacheConfiguration()`. Для создания кеша с определенным режимом репликации используйте предустановленные шаблоны `TEMPLATE=PARTITIONED` или `TEMPLATE=REPLICATED`. Остальные параметры берутся из объекта `CacheConfiguration`. По умолчанию (если шаблон не указан явно) применяется `TEMPLATE=PARTITIONED`.
   - `BACKUPS=<number of backups>` устанавливает количество резервных копий партиций. Если данный параметр и параметр `TEMPLATE` не указаны, кеш создается с нулевым количеством резервных копий.
   - `ATOMICITY=<ATOMIC | TRANSACTIONAL>` задает режим атомарности для кеша. Если данный параметр и параметр `TEMPLATE` не указаны, кеш создается с активным режимом `ATOMIC`.
   - `WRITE_SYNCHRONIZATION_MODE=<PRIMARY_SYNC | FULL_SYNC | FULL_ASYNC>` задает режим синхронизации записи для кеша. Если данный параметр и параметр `TEMPLATE` не указаны, кеш создается с режимом `FULL_SYNC`.
   - `CACHE_GROUP=<group name>` указывает имя кеш-группы, к которой относится данный кеш.
   - `AFFINITY_KEY=<affinity key column name>` задает имя колонки, которая используется в качестве affinity-ключа.
   - `CACHE_NAME=<custom name of the new cache>` — имя создаваемого кеша. Если параметр не указан, используется формат `SQL_{SCHEMA_NAME}_{TABLE}`.
   - `DATA_REGION=<existing data region name>` — имя региона данных, в котором следует хранить записи таблицы. Если не указаны дополнительные настройки, DataGrid использует регион данных, который определен по умолчанию.
   - `PARALLELISM=<number of SQL execution threads>` — по умолчанию SQL-запросы обрабатываются одним потоком на каждом узле, но иногда может потребоваться параллельное выполнение. Подробнее об этом написано в подразделе [«Параллелизм запросов»](../../troubleshooting-and-performance/md/performance-tuning.md#параллелизм-запросов) документа «Настройка производительности».
   - `KEY_TYPE=<custom name of the key type>` задает имя пользовательского типа ключа, который применяется в Key-Value API в DataGrid. Имя должно соответствовать классу Java, .NET, C++ или быть произвольным (если вместо пользовательского класса используются `BinaryObjects` — подробнее о них написано в подразделе [«Формат хранения записей данных»](introduction.md#формат-хранения-записей-данных) раздела «Моделирование данных»). Количество полей и их типы в пользовательском типе ключа должны совпадать с `PRIMARY KEY` (подробнее об этом написано ниже в разделе «[](#использование-non-sql-api)»).
   - `VALUE_TYPE=<custom name of the value type of the new cache>` задает имя пользовательского типа значения, которое используется в Key-Value API и других non-SQL API в DataGrid. Имя должно соответствовать классу Java, .NET, C++ или быть произвольным (если вместо пользовательского класса применяются `BinaryObjects` — подробнее о них написано в подразделе [«Формат хранения записей данных»](introduction.md#формат-хранения-записей-данных) раздела «Моделирование данных»). Тип значения должен включать все столбцы, которые определены в команде `CREATE TABLE`, кроме перечисленных в ограничении `PRIMARY KEY` (подробнее об этом написано ниже в разделе «[](#использование-non-sql-api)»). Также параметр `VALUE_TYPE` нужен для выполнения SQL-запросов над данными, которые реплицированы с помощью механизма CDC.
   - `WRAP_KEY=<true | false>` — флаг контролирует необходимость обертки (wrapping) одностолбцового `PRIMARY KEY` в формат `BinaryObjects` (подробнее о нем написано в подразделе [«Формат хранения записей данных»](introduction.md#формат-хранения-записей-данных) раздела «Моделирование данных»). По умолчанию установлено значение `false`. Этот флаг не влияет на `PRIMARY KEY` с несколькими столбцами — они всегда оборачиваются независимо от значения флага.
    - `WRAP_VALUE=<true | false>` — флаг контролирует необходимость обертки (wrapping) значения одностолбцового примитивного типа в формат `BinaryObjects` (подробнее о нем написано в подразделе [«Формат хранения записей данных»](introduction.md#формат-хранения-записей-данных)). По умолчанию установлено значение `true`. Этот флаг не влияет на значения с несколькими столбцами — они всегда оборачиваются независимо от значения флага. Установите данный параметр на `false`, если значение состоит из одного столбца и не планируется добавлять новые столбцы в таблицу. После установки значения параметра `false` не получится использовать команду `ALTER TABLE ADD COLUMN` для данной таблицы.

### Определение первичного ключа (primary key)

В примере ниже демонстрируется создание таблицы с указанием `PRIMARY KEY` в одном из столбцов и настройка параметров, которые связаны с кешем. Будет создан новый распределенный кеш с именем `SQL_PUBLIC_PERSON` (имена формируются по шаблону `SQL_{SCHEMA_NAME}_{TABLE}`). Этот кеш будет хранить объекты типа `Person`, которые соответствуют классам Java, .NET, C++ или типу `BinaryObject`.

Параметры распределенного кеша задаются с помощью оператора `WITH` внутри SQL-запроса. Если оператор `WITH` отсутствует, кеш создается с использованием параметров по умолчанию, которые указаны в конфигурации кеша (`CacheConfiguration`).

:::{code-block} sql
:caption: SQL
CREATE TABLE Person (
  id int PRIMARY KEY,
  city_id int,
  name varchar,
  age int,
  company varchar
) WITH "atomicity=transactional,cachegroup=somegroup";
:::

### Использование non-SQL API

Для доступа к данным таблицы с помощью Key-Value API или других non-SQL API укажите параметры `CACHE_NAME`, `KEY_TYPE` и `VALUE_TYPE`, которые соответствуют объектам бизнес-модели (это сделает работу с non-SQL API удобнее):

- Параметр `CACHE_NAME` позволяет изменить стандартное имя кеша (`SQL_{SCHEMA_NAME}_{TABLE}`).
- По умолчанию создаются два новых бинарных типа —— для ключей и для значений. Их имена генерируются автоматически и включают UUID (универсальный уникальный идентификатор), что затрудняет использование этих типов с помощью non-SQL API.

Ниже приведен пример создания таблицы `Person` и соответствующего ей кеша с теми же именами. В данном случае кеш будет содержать объекты типа `Person`, где у ключа тип `PersonKey`, а у значения — `PersonValue`. Поля, которые указаны как `PRIMARY KEY`, будут использованы в качестве ключей объектов, а остальные станут частью значения.

:::{code-block} sql
:caption: SQL
CREATE TABLE IF NOT EXISTS Person (
  id int,
  city_id int,
  name varchar,
  age int,
  company varchar,
  PRIMARY KEY (id, city_id)
) WITH "template=partitioned,backups=1,affinity_key=city_id,CACHE_NAME=Person,KEY_TYPE=PersonKey,VALUE_TYPE=PersonValue";
:::

### Использование столбцов без верхнего регистра

Во время выполнения команды `CREATE TABLE` DataGrid анализирует все не заключенные в кавычки идентификаторы и имена столбцов таблицы и преобразует их в верхний регистр. Это делает команду с явным указанием типов ключа и значения более сложной. Чтобы упростить задачу, воспользуйтесь следующими методами:

- Применяйте аннотацию `QuerySqlField`. Это позволит избежать повторной проверки полей без учета регистра, поскольку псевдоним для столбца (column alias) генерируется каждый раз при выполнении команды `CREATE TABLE`.
- Убедитесь, что поля в DDL-запросах и поля типа кеша совпадают по регистру символов (так как имена столбцов по умолчанию приводятся к верхнему регистру).

В примере ниже показано, как в команде `CREATE TABLE` используются кавычки для поля `affKey`, которое написано в стиле `CamelCase`. При этом важно обеспечить соответствие этого поля полю в типе ключа кеша `PersonKey`.

:::{code-block} sql
:caption: SQL
CREATE TABLE IF NOT EXISTS Person (
  id INT,
  "affKey" INT,
  val VARCHAR,
  PRIMARY KEY (id, "affKey")
) WITH "template=partitioned,backups=1,affinity_key=affKey,CACHE_NAME=Person,KEY_TYPE=PersonKey,VALUE_TYPE=PersonValue";
:::

:::{code-block} java
:caption: Java
class PersonKey {
    private int id;
 
    /* Поле `affKey`, которое записано в стиле `CamelCase`, должно соответствовать схеме таблицы в DDL. Чтобы избежать ошибок, важно учесть следующее:
     * - Убедитесь, что в определении DDL-таблицы имя поля указано в кавычках: "affKey".
     * - Преобразуйте поле `affKey` в верхний регистр (`AFFKEY`), чтобы оно соответствовало определению в DDL.
     */
    @AffinityKeyMapped
    private int affKey;
 
    public PersonKey(int id, int affKey) {
        this.id = id;
        this.affKey = affKey;
    }
}
:::

:::{admonition} Примечание
:class: note
Некоторые интеграции с DataGrid, например `CrudRepository` Spring Data, не работают с полями в кавычках при доступе к данным.
:::

## ALTER TABLE

Команда `ALTER TABLE` позволяет менять структуру уже существующей таблицы:

:::{code-block} sql
:caption: SQL
ALTER TABLE [IF EXISTS] tableName {alter_specification}
 
alter_specification:
    ADD [COLUMN] {[IF NOT EXISTS] tableColumn | (tableColumn [,...])}
  | DROP [COLUMN] {[IF EXISTS] columnName | (columnName [,...])}
  | {LOGGING | NOLOGGING}
 
tableColumn := columnName columnType
:::

### Применение команды ALTER TABLE

На данный момент DataGrid поддерживает только добавление и удаление столбцов.

**Параметры команды `ALTER TABLE`:**

- `tableName` — имя изменяемой таблицы.
- `tableColumn` — имя и тип добавляемого столбца.
- `columnName` — имя столбца, который добавляется или удаляется.
- `IF EXISTS` предотвращает генерацию ошибки, если таблицы или столбца с указанным именем не существует.
- `IF NOT EXISTS` предотвращает генерацию ошибки, если столбец с таким именем уже существует.
- `LOGGING` включает ведение WAL-журнала для таблицы (включено по умолчанию). Применимо только при использовании персистентности DataGrid.
- `NOLOGGING` отключает ведение WAL-журнала для таблицы. Применимо только при использовании персистентности DataGrid.

Команда `ALTER TABLE ADD` добавляет один или несколько новых столбцов в уже существующую таблицу. После добавления столбца можно обращаться к нему с помощью DML-команд и создавать индексы с помощью команды `CREATE INDEX`.

Команда `ALTER TABLE DROP` удаляет один или несколько существующих столбцов из таблицы. После удаления столбца доступ к нему в запросах становится невозможным. Учитывайте следующие особенности и ограничения:

- Команда не удаляет сами данные из кластера. Например, если удален столбец `name`, его значение все равно останется сохраненным в кластере. Это ограничение планируется устранить в будущих версиях.
- Если столбец был проиндексирован, индекс потребуется удалить вручную с помощью команды `DROP INDEX` (подробнее о ней написано ниже в разделе «[](#drop-table)»).
- Нельзя удалить столбец, который является первичным ключом или входит в его состав.
- Нельзя удалить столбец, если он содержит единственное значение, которое хранится в кластере (ограничение применимо к примитивным значениям).

DataGrid хранит данные в виде пар «ключ-значение», поэтому все новые столбцы будут относиться к значению. Изменить набор столбцов ключа (`PRIMARY KEY`) невозможно.

DDL- и DML-команды, которые направлены на одну и ту же таблицу, блокируются во время выполнения команды `ALTER TABLE`.

Если включена персистентность DataGrid, изменения схемы, которые вносит данная команда, записываются на диск. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Примеры

**Добавление нового столбца в таблицу `Person`:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Person ADD COLUMN city varchar;
:::

**Добавление нового столбца в таблицу `City` только в том случае, если столбца с таким именем не существует:**

:::{code-block} sql
:caption: SQL
ALTER TABLE City ADD COLUMN IF NOT EXISTS population int;
:::

**Добавление столбца только в том случае, если таблица существует:**

:::{code-block} sql
:caption: SQL
ALTER TABLE IF EXISTS Missing ADD number long;
:::

**Одновременное добавление нескольких столбцов в таблицу:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Region ADD COLUMN (code varchar, gdp double);
:::

**Удаление столбца из таблицы:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Person DROP COLUMN city;
:::

**Удаление столбца из таблицы только в том случае, если столбец с таким именем уже существует:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Person DROP COLUMN IF EXISTS population;
:::

**Удаление столбца только в том случае, если таблица существует:**

:::{code-block} sql
:caption: SQL
ALTER TABLE IF EXISTS Person DROP COLUMN number;
:::

**Одновременное удаление нескольких столбцов из таблицы:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Person DROP COLUMN (code, gdp);
:::

**Отключение ведения WAL-журнала:**

:::{code-block} sql
:caption: SQL
ALTER TABLE Person NOLOGGING
:::

## DROP TABLE

Команда `DROP TABLE` удаляет существующую таблицу вместе с кешем и всеми данными, которые содержатся в ней.

:::{code-block} sql
:caption: SQL
DROP TABLE [IF EXISTS] tableName
:::

**Параметры команды `DROP TABLE`:**

- `tableName` — имя таблицы, которую нужно удалить.
- `IF NOT EXISTS` предотвращает генерацию ошибки, если таблица с указанным именем отсутствует.

При выполнении команды `DROP TABLE` все другие DDL- и DML-операторы, которые направлены на эту таблицу, временно блокируются. После удаления таблицы все ожидающие команды завершатся с ошибкой.

Если включена персистентность DataGrid, изменения схемы базы данных, которые внесены данной командой, сохраняются на диске. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Примеры

**Удаление таблицы `Person`, если она существует (команда предотвратит генерацию ошибки, если таблица `Person` не найдена):**

:::{code-block} sql
:caption: SQL
DROP TABLE IF EXISTS "Person";
:::

## CREATE INDEX

Команда `CREATE INDEX` создает индекс для указанной таблицы:

:::{code-block} sql
:caption: SQL
CREATE [SPATIAL] INDEX [[IF NOT EXISTS] indexName] ON tableName
    (columnName [ASC|DESC] [,...]) [(index_option [...])]
 
index_option := {INLINE_SIZE size | PARALLEL parallelism_level}
:::

**Параметры команды `CREATE INDEX`:**

- `indexName` — имя создаваемого индекса (должно быть уникальным в рамках одной схемы).
- `ASC` указывает сортировку по возрастанию (используется по умолчанию).
- `DESC` указывает сортировку по убыванию.
- `SPATIAL` создает пространственный индекс, поддерживает геометрические типы данных.
- `IF NOT EXISTS` предотвращает генерацию ошибки, если индекс с таким именем уже существует. Проверка осуществляется только по имени индекса, но не по типам столбцов или их количеству. Создание индекса пропускается, если индекс с таким именем уже присутствует на схеме.
- `index_option` — дополнительные параметры для создания индекса:

   - `INLINE_SIZE` определяет размер встроенного индекса в байтах. В зависимости от указанного размера, DataGrid может разместить весь проиндексированный элемент или его часть прямо на страницах индекса, избегая дополнительных обращений к страницам данных и повышая скорость выполнения запросов. По умолчанию встраивание включено, а размер рассчитывается автоматически на основе структуры таблицы. Чтобы отключить встраивание, установите размер равным нулю (не рекомендуется).
   - `PARALLEL` определяет количество потоков, которые работают параллельно для создания индекса. Чем выше значение, тем быстрее происходит создание индекса. Если указанное значение превышает количество процессоров, оно будет уменьшено до количества доступных ядер. Если параметр не указан, количество потоков вычисляется как 25% от общего числа доступных ядер CPU.

Команда `CREATE INDEX` используется для создания нового индекса для указанной таблицы. Индексы обычного типа хранятся в структуре данных типа B+ дерева, которая распределяется по всему кластеру вместе с реальными данными. Каждый узел кластера хранит фрагменты индекса для тех данных, которыми он управляет.

Если команда `CREATE INDEX` выполняется в режиме реального времени на активных данных, база данных синхронно проходит по указанным колонкам, создавая индекс. Другие DDL-команды, которые направлены на ту же таблицу, будут заблокированы до завершения процесса создания индекса. DML-команды могут выполняться параллельно и не затрагиваются этим процессом.

Если включена персистентность DataGrid, изменения схемы базы данных, которые внесены данной командой, сохраняются на диске. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Компромисс (tradeoff) при создании индексов

При выборе индексов для приложения учитывайте несколько важных аспектов:

- Индексы потребляют ресурсы. Они занимают память, и каждый индекс требует отдельного обновления. Это может замедлить операции записи, особенно если создано чрезмерное количество индексов. Также наличие большого количества индексов увеличивает вероятность ошибок оптимизатора, который может выбрать неподходящий индекс при составлении плана выполнения запроса.
   
   :::{admonition} Важно
   :class: attention
   Индексировать все подряд — некорректная стратегия.
   :::

- Индексы являются упорядоченными структурами данных (например, B+ дерево). Если создается индекс для полей (`a`, `b`, `c`), записи сначала сортируются по полю `a`, затем — по полю `b`, и только после этого по полю `c`.

   **Пример отсортированного индекса:**

   | a | b | c |
   |---|---|---|
   | 1 | 2 | 3 |
   | 1 | 4 | 2 |
   | 1 | 4 | 4 |
   | 2 | 3 | 5 |
   | 2 | 4 | 4 |
   | 2 | 4 | 5 |

   Например, условие вида `a = 1 AND b > 3` можно интерпретировать как ограниченный диапазон, обе границы которого можно быстро найти за логарифмическое время. Результатом будет набор записей, которые находятся между этими границами.

   **Условия, которые смогут использовать данный индекс:**

   - `a = ?`;
   - `a = ? AND b = ?`;
   - `a = ? AND b = ? AND c = ?`.

   Условие `a = ? AND c = ?` не принесет никакой дополнительной выгоды по сравнению с условием `a = ?` с точки зрения использования индекса. Полуограниченные диапазоны, например `a > ?`, также могут быть полезными.

- У однополевых индексов (single field index) нет преимуществ перед составными индексами (multiple field index), которые состоят из нескольких полей начиная с того же самого поля. Например, индекс на `(a)` не лучше, чем на `(a, b, c)`. Предпочтительно использовать составные индексы.
- Когда используется опция `INLINE_SIZE`, индексы включают в себя префиксы данных поля на страницах B+ дерева. Это ускоряет поиск (так как уменьшается количество извлечений строковых данных), но существенно увеличивает размер дерева (при умеренном увеличении его высоты) и ухудшает производительность операций вставки и удаления данных из-за частых разбиений и слияний страниц. Рекомендуется учитывать размер страницы при выборе размера встраиваемого индекса: каждая запись B+ дерева занимает `16 + inline-size` байтов на странице (плюс заголовок и дополнительные ссылки для страницы).

### Примеры

**Создание обычного индекса:**

:::{code-block} sql
:caption: SQL
CREATE INDEX title_idx ON books (title);
:::

**Создание индекса с порядком сортировки по убыванию, если такого индекса не существует:**

:::{code-block} sql
:caption: SQL
CREATE INDEX IF NOT EXISTS name_idx ON persons (firstName DESC);
:::

**Создание составного индекса:**

:::{code-block} sql
:caption: SQL
CREATE INDEX city_idx ON sales (country, city);
:::

**Создание индекса с указанием размера встроенных данных (`inlinesize`):**

:::{code-block} sql
:caption: SQL
CREATE INDEX fast_city_idx ON sales (country, city) INLINE_SIZE 60;
:::

**Создание геопространственного (geospatial) индекса:**

:::{code-block} sql
:caption: SQL
CREATE SPATIAL INDEX idx_person_address ON Person (address);
:::

## DROP INDEX

Команда `DROP INDEX` предназначена для удаления существующего индекса:

:::{code-block} sql
:caption: SQL
DROP INDEX [IF EXISTS] indexName
:::

**Параметры команды `DROP INDEX`:**

- `indexName` — имя индекса, который нужно удалить.
- `IF EXISTS` предотвращает генерацию ошибки, если индекса с указанным именем не существует. База данных проверяет только имена индексов и игнорирует типы столбцов и их количество.

Все DDL-команды, которые направлены на ту же таблицу, будут заблокированы до завершения операции `DROP INDEX`. DML-команды могут выполняться параллельно и не затрагиваются этим процессом.

Если включена персистентность DataGrid, изменения схемы базы данных, которые внесены данной командой, сохраняются на диске. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Примеры

**Удаление индекса:**

:::{code-block} sql
:caption: SQL
DROP INDEX idx_person_name;
:::

## CREATE VIEW

Команда `CREATE VIEW` создает пользовательское SQL-представление:

:::{code-block} sql
:caption: SQL
CREATE [OR REPLACE] VIEW [schemaName.]viewName AS query
:::

**Параметры команды `CREATE VIEW`:**

- `schemaName` — имя схемы, в которой будет создано SQL-представление. Если не указано, используется текущая схема.
- `viewName` — имя создаваемого SQL-представления.
- `OR REPLACE` замещает SQL-представление с таким же именем, если оно уже существует.
- `query` — допустимый SQL-запрос, на основе которого будет создано SQL-представление.

Если включена персистентность DataGrid, изменения схемы базы данных, которые внесены данной командой, сохраняются на диске. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Примеры

**Создание SQL-представления:**

:::{code-block} sql
:caption: SQL
CREATE VIEW adult AS SELECT * FROM person WHERE age >= 18;
:::

## DROP VIEW

Команда `DROP VIEW` удаляет существующее пользовательское SQL-представление:

:::{code-block} sql
:caption: SQL
DROP VIEW [IF EXISTS] [schemaName.]viewName
:::

**Параметры команды `DROP VIEW`:**

- `schemaName` — схема с SQL-представлением, которое нужно удалить.
- `viewName` — имя SQL-представления, которое нужно удалить.
- `IF EXISTS` предотвращает генерацию ошибки, если SQL-представления с указанным именем не существует.

Если включена персистентность DataGrid, изменения схемы базы данных, которые внесены данной командой, сохраняются на диске. Благодаря этому изменения могут сохраняться даже после полного перезапуска кластера.

### Примеры

**Удаление SQL-представления:**

:::{code-block} sql
:caption: SQL
DROP VIEW adult;
:::

## CREATE USER

Команда `CREATE USER` создает нового пользователя с указанными именем и паролем.

Если включена аутентификация для тонких клиентов, новых пользователей может создавать только суперпользователь. При первом запуске кластера DataGrid автоматически создает учетную запись суперпользователя с именем `ignite` и паролем `ignite`. В настоящий момент нельзя переименовывать учетную запись суперпользователя или передавать его привилегии другому пользователю.

:::{code-block} sql
:caption: SQL
CREATE USER userName WITH PASSWORD 'password';
:::

**Параметры команды `CREATE USER`:**

- `userName` — имя нового пользователя. Максимальная длина имени — 60 символов в кодировке UTF-8.
- `password` — пароль нового пользователя. Использование пустого пароля запрещено.

Для создания имени пользователя, которое будет чувствительно к регистру, используйте двойные кавычки (`""`) вокруг него при написании SQL-запросов.

:::{admonition} Внимание
:class: danger
Имена пользователей, которые используются в интерфейсах JDBC и ODBC, нечувствительны к регистру. Если планируется работать с базой данных с помощью других языков программирования, например Java или .NET, убедитесь, что имя пользователя передается полностью прописными (заглавными) символами или заключается в двойные кавычки.
:::

**Варианты использования для пользователя с именем `Test`:**

- С помощью интерфейсов JDBC и ODBC можно применять любые вариации регистра символов, например, `Test`, `TEst`, `TEST` и другие.
- Для работы с базами данных с помощью собственных SQL-интерфейсов DataGrid, которые предназначены для Java, .NET и прочих языков программирования, в качестве имени пользователя используйте `TEST` или `"Test"`.

Рекомендуется всегда использовать имя пользователя, которое чувствительно к регистру, чтобы обеспечить единообразие имен во всех SQL-интерфейсах.

### Примеры

**Создание нового пользователя с именем `test` и паролем:**

:::{code-block} sql
:caption: SQL
CREATE USER test WITH PASSWORD 'test';
:::

**Создание имени пользователя, которое чувствительно к регистру:**

:::{code-block} sql
:caption: SQL
CREATE USER "TeSt" WITH PASSWORD 'test'
:::

## ALTER USER

Команда `ALTER USER` позволяет изменить пароль существующего пользователя. Обновить пароль может сам пользователь или суперпользователь (например, пользователь `ignite` — подробнее о нем написано выше в разделе «[](#create-user)»).

:::{code-block} sql
:caption: SQL
ALTER USER userName WITH PASSWORD 'newPassword';
:::

**Параметры команды `ALTER USER`:**

- `userName` — имя существующего пользователя.
- `newPassword` — новый пароль, который будет установлен для учетной записи пользователя.

### Примеры

**Обновление пароля пользователя:**

:::{code-block} sql
:caption: SQL
ALTER USER test WITH PASSWORD 'test123';
:::

## DROP USER

Команда `DROP USER` используется для удаления существующего пользователя. Удалить пользователя может только суперпользователь (например, пользователь `ignite` — подробнее о нем написано выше в разделе «[](#create-user)»).

:::{code-block} sql
:caption: SQL
DROP USER userName;
:::

**Параметры команды `DROP USER`:**

- `userName` — имя пользователя, которого нужно удалить.

### Примеры

**Удаление пользователя с именем `test`:**

:::{code-block} sql
:caption: SQL
DROP USER test;
:::

## ANALYZE

Команда `ANALYZE` используется для сбора статистики. Подробнее о работе со статистикой написано в подразделе [«SQL-статистика»](../../administration-guide/md/sql-calcite-engine.md#sql-статистика) раздела «Работа с SQL и Apache Calcite» документа «Руководство по системному администрированию».

:::{code-block} sql
:caption: SQL
ANALYZE 'schemaName'.'tableName'(column1, column2);
:::

**Параметры команды `ANALYZE`:**

- `schemaName` — имя схемы, для которой нужно собрать статистику.
- `tableName` — имя таблицы, для которой нужно собрать статистику.
- `(column1, column2, ...)` — имена столбцов, для которых нужно собрать статистику.

Когда команда `ANALYZE` используется с параметром `WITH`, дополнительный параметр применяется ко всем указанным целям. Например:

:::{code-block} sql
:caption: SQL
ANALYZE public.statistics_test, statistics_test2, statistics_test3(col3) WITH 'MAX_CHANGED_PARTITION_ROWS_PERCENT=15,NULLS=0'
:::

**Возможные дополнительные параметры:**

- `MAX_CHANGED_PARTITION_ROWS_PERCENT` — максимальный процент устаревших строк в таблице (по умолчанию — 15%). Подробнее об этом написано в подразделе [«SQL-статистика»](../../administration-guide/md/sql-calcite-engine.md#sql-статистика) раздела «Работа с SQL и Apache Calcite» документа «Руководство по системному администрированию».
- `NULLS` — количество значений `NULL` в колонке.
- `TOTAL` — общее количество значений в колонке.
- `SIZE` — средний размер значений в колонке (в байтах).
- `DISTINCT` — количество уникальных непустых значений в колонке.

## REFRESH STATISTICS

Команда `REFRESH STATISTICS` обновляет собранную ранее статистику. Подробнее о работе со статистикой написано в подразделе [«SQL-статистика»](../../administration-guide/md/sql-calcite-engine.md#sql-статистика) раздела «Работа с SQL и Apache Calcite» документа «Руководство по системному администрированию».

:::{code-block} sql
:caption: SQL
REFRESH STATISTICS 'schemaName'.'tableName'(column1, column2);
:::

**Параметры команды `REFRESH STATISTICS`:**

- `schemaName` — имя схемы, для которой нужно обновить статистику.
- `tableName` — имя таблицы, для которой нужно обновить статистику.
- `(column1, column2, ...)` — имена столбцов, для которых нужно обновить статистику.

### Примеры

**Пример обновления статистики:**

:::{code-block} sql
:caption: SQL
REFRESH STATISTICS PRODUCTS, SALE(productId, discount)
:::

## DROP STATISTICS

Команда `DROP STATISTICS` удаляет ранее собранную статистику. Подробнее о работе со статистикой написано в подразделе [«SQL-статистика»](../../administration-guide/md/sql-calcite-engine.md#sql-статистика) раздела «Работа с SQL и Apache Calcite» документа «Руководство по системному администрированию».

:::{code-block} sql
:caption: SQL
DROP STATISTICS 'schemaName'.'tableName'(column1, column2);
:::

**Параметры команды `DROP STATISTICS`:**

- `schemaName` — имя схемы, для которой нужно удалить статистику.
- `tableName` — имя таблицы, для которой нужно удалить статистику.
- `(column1, column2, ...)` — имена столбцов, для которых нужно удалить статистику.

### Примеры

**Пример удаления статистики:**

:::{code-block} sql
:caption: SQL
DROP STATISTICS USERS, ORDERS(customerId, productId)
:::