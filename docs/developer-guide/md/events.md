# События

В разделе описаны типы событий, когда и где они генерируются, а также как их можно использовать.

## Общая информация

Все события реализуют интерфейс `Event`. Чтобы получить расширенную информацию о действии, которое вызвало событие, может потребоваться привести каждое событие к определенному типу. Например, обновление кеша запускает событие, которое является экземпляром класса `CacheEvent`. Он содержит информацию об измененных данных, идентификатор субъекта, который вызвал событие, и так далее.

Все события содержат информацию об узле, на котором они сгенерировались. Например, при запуске задания `IgniteClosure` события `EVT_JOB_STARTED` и `EVT_JOB_FINISHED` содержат информацию об узле, на котором выполнилась функция (closure):

```bash
IgniteEvents events = ignite.events();

UUID uuid = events.remoteListen(new IgniteBiPredicate<UUID, JobEvent>() {
    @Override
    public boolean apply(UUID uuid, JobEvent e) {

        System.out.println("nodeID = " + e.node().id() + ", addresses=" + e.node().addresses());

        return true; // Продолжайте прослушивание событий.
    }
}, null, EventType.EVT_JOB_FINISHED);
```

:::{admonition} Порядок событий
:class: hint

Порядок событий в слушателе может не совпадать с порядком генерации событий.
:::

### SubjectID

У некоторых событий есть поле `subjectID` — идентификатор сущности, который инициировал действие:

- Когда действие инициируется серверным или клиентским узлом, `subjectID` является идентификатором этого узла.
- Когда действие выполняется тонким клиентом или клиентом JDBC/ODBC/REST, идентификатор `subjectID` генерируется при подключении клиента к кластеру и остается неизменным, пока сохраняется подключение.

Проверьте конкретный тип событий, чтобы узнать, присутствует ли в нем поле `subjectID`.

## События изменения состояния кластера

События изменения состояния кластера — экземпляры класса `ClusterStateChangeEvent`.

События такого типа генерируются при изменении состояния кластера, которое происходит при автоматической активации или ручном изменении состояния кластера. События включают новые и старые состояния и список узлов базовой топологии после изменения.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CLUSTER_STATE_CHANGED` | Изменение состояния кластера | Все узлы кластера |

## События жизненного цикла кешей

События жизненного цикла кешей — экземпляры класса `CacheEvent`. Каждое из них связано с определенным кешем и содержит поле с его именем.

:::{list-table}
:header-rows: 1
 
+   *   Тип события
    *   Описание события
    *   Место, где генерируется событие
+   *   `EVT_CACHE_STARTED`
    *   Кеш запускается на определенном узле. В каждом серверном узле есть внутренний экземпляр кеша. Примеры действий, при которых генерируется событие:
        - Активация кластера с существующим кешем. Событие генерируется для каждого кеша на всех серверных узлах, в которых он настроен.
        - Серверный узел присоединяется к кластеру с существующими кешами (они запускаются на этом узле).
        - Динамическое создание нового кеша с помощью вызова `Ignite.getOrCreateCache(…)` или похожих методов. Событие генерируется на всех узлах, где есть кеш. 
        - Получение экземпляра кеша на клиентском узле.
        - Создание кеша через команду `CREATE TABLE` — подробнее о ней написано в [официальной документации Apache Ignite](https://ignite.apache.org/docs/latest/sql-reference/ddl#create-tablehttps://ignite.apache.org/docs/latest/sql-reference/ddl#create-table)
    *   Все узлы кластера, где запускаются кеши
+   *   `EVT_CACHE_STOPPED`
    *   Примеры действий, при которых генерируется событие:
        - Деактивация кластера. Все кеши на всех серверных узлах останавливаются.
        - Вызов метода `IgniteCache.close()`. Событие генерируется на узле, где вызывается метод.
        - Удаление SQL-таблицы.
        - При вызове `cache = Ignite.getOrCreateCache(…)` и последующем вызове  `Ignite.close()` кеш также закрывается на том же узле
    *   Все узлы кластера, на которых остановили кеш
+   *   `EVT_CACHE_NODES_LEFT`
    *   Все узлы, в которых есть определенный кеш, покидают кластер. Это возможно в ситуациях, когда:
        - кеш развернут на подмножестве серверных узлов;
        - все серверные узлы покидают кластер и остаются только клиентские узлы
    *   Все оставшиеся узлы кластера
:::

## События кешей

События кешей — экземпляры класса `CacheEvent`. Они представляют операции над объектами кеша, например `get`, `put`, `remove`, `lock` и другие.

Каждое событие содержит информацию о:

- кеше;
- ключе, к которому обращается операция;
- значении до и после операции (если применимо) и так далее.

События кеша также генерируются при использовании DML-команд.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CACHE_OBJECT_PUT` | Объект помещается в кеш. Событие генерируется при каждом вызове `IgniteCache.put()`. Пакетные операции, например `putAll(…)`, создают несколько событий данного типа | Основной (primary) и резервные (backup) узлы для записи |
| `EVT_CACHE_OBJECT_READ` | Объект читается из кеша. Событие не генерируется при использовании запросов сканирования (подробнее о них написано в подразделе [«Использование Cache Queries»](using_cache_queries.md) раздела «Использование Key-Value API»). Для мониторинга запросов сканирования используйте [события запросов к кешам](#события-запросов-к-кешам) | Узел, на котором выполняется операция чтения. Это может быть основной или резервный узел. Второй случай возможен только при включенном чтении из резервных копий — подробнее о нем написано в подразделе [«Конфигурация кешей»](cache_setup.md) раздела «Настройка кешей». В транзакционных кешах событие может генерироваться и на основном, и на резервном узлах в зависимости от уровней параллелизма и изоляции |
| `EVT_CACHE_OBJECT_REMOVED` | Объект удален из кеша | Основной и резервные узлы для записи |
| `EVT_CACHE_OBJECT_LOCKED` | Блокировка устанавливается на конкретный ключ в транзакционных кешах. Действия пользователя, которые приводят к блокировке:<br>1. Пользователь явно получает блокировку с помощью вызова метода `IgniteCache.lock()` или `IgniteCache.lockAll()`.<br>2. Блокировка устанавливается для каждой атомарной (нетранзакционной) операции изменения данных (`put`, `update`, `remove`). Событие срабатывает на основном и резервном узлах ключа.<br>3. Блокировки устанавливаются на ключах, к которым осуществляется доступ в рамках транзакции в зависимости от уровней параллелизма и изоляции (подробнее о них написано в разделе [«Выполнение транзакций»](execution_of_transactions.md)) | Основной и/или резервные узлы для записи в зависимости от уровней параллелизма и изоляции — подробнее о них написано в разделе [«Выполнение транзакций»](execution_of_transactions.md) |
| `EVT_CACHE_OBJECT_UNLOCKED` | Блокировка ключа снимается | Основной узел для записи |
| `EVT_CACHE_OBJECT_EXPIRED` | Событие вызывается, когда истекает срок действия записи в кеше. Это происходит только в том случае, если настроена политика потери партиций — подробнее о ней написано в подразделе [«Политика потери партиций (Partition Loss Policy)»](partition_loss_policy.md) раздела «Настройка кешей» | Основной и резервные узлы для записи |
| `EVT_CACHE_ENTRY_CREATED` | Событие вызывается, когда DataGrid создает внутреннюю запись для работы с определенным объектом кеша. Не рекомендуется использовать это событие. Для мониторинга большинства операций добавления кеша достаточно использовать событие `EVT_CACHE_OBJECT_PUT` | Основной и резервные узлы для записи |
| `EVT_CACHE_ENTRY_DESTROYED` | Событие вызывается, когда DataGrid уничтожает внутреннюю запись для работы с определенным объектом кеша. Не рекомендуется использовать это событие. Уничтожение внутренней записи не удаляет данные из кеша. Для мониторинга операций удаления кеша используйте событие `EVT_CACHE_OBJECT_REMOVED` | Основной и резервные узлы для записи |

## События запросов к кешам

Есть два типа событий, которые связаны с запросами к кешам:

- события запросов чтения объектов кеша, которые являются экземплярами класса `CacheQueryReadEvent`;
- события выполнения запросов к кешам, которые являются экземплярами класса `CacheQueryExecutedEvent`.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CACHE_QUERY_OBJECT_READ` | Объект считывается как часть выполнения запроса. Событие генерируется для каждого объекта, который соответствует фильтру запроса (подробнее о нем написано в подразделе [«Использование Cache Queries»](using_cache_queries.md) раздела «Использование Key-Value API») | Основной узел считываемого объекта |
| `EVT_CACHE_QUERY_EXECUTED` | Событие генерируется при выполнении запроса | Все серверные узлы, в которых есть кеш |

## События развертывания классов и задач

События развертывания являются экземплярами класса `DeploymentEvent`.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CLASS_DEPLOYED` | Класс (не задача) развернут на определенном узле | Узел, на котором развернут класс |
| `EVT_CLASS_UNDEPLOYED` | Класс не развернут | Узел, на котором не развернут класс |
| `EVT_CLASS_DEPLOY_FAILED` | Развертывание класса не выполнилось успешно | Узел, на котором должен быть развернут класс |
| `EVT_TASK_DEPLOYED` | Класс задачи развернут на определенном узле | Узел, на котором развернут класс |
| `EVT_TASK_UNDEPLOYED` | Класс задачи не развернут на определенном узле | Узел, на котором не развернут класс |
| `EVT_TASK_DEPLOY_FAILED` | Развертывание класса не выполнилось успешно | Узел, на котором должен быть развернут класс |

## Discovery-события

Discovery-события происходят, когда серверные и клиентские узлы присоединяются к кластеру или покидают его, в том числе когда узлы покидают кластер из-за сбоя.

События обнаружения являются экземплярами класса `DiscoveryEvent`.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_NODE_JOINED` | Узел присоединяется к кластеру | Все узлы в кластере (кроме того, который присоединился) |
| `EVT_NODE_LEFT` | Узел покидает кластер | Все оставшиеся узлы кластера |
| `EVT_NODE_FAILED` | Кластер обнаруживает, что узел покинул его некорректным способом | Все оставшиеся узлы кластера |
| `EVT_NODE_SEGMENTED` | Событие происходит на узле, который решил, что он сегментировался | Узел, который сегментировался |
| `EVT_CLIENT_NODE_DISCONNECTED` | Клиентский узел теряет подключение к кластеру | Клиентский узел, который отключился от кластера |
| `EVT_CLIENT_NODE_RECONNECTED` | Клиентский узел повторно подключается к кластеру | Клиентский узел, который повторно подключился к кластеру |

## События выполнения задач

События выполнения задач связаны с разными стадиями их выполнения (подробнее о стадиях написано в подразделе [MapReduce API](mapreduce_api.md) раздела «Распределенные вычисления»). Они также генерируются при выполнении простых задач по распределенным вычислениям (подробнее написано в разделе [«Распределенные вычисления»](distributed_computing.md)): внутри такая операция рассматривается как задача, которая создает одно задание.

События выполнения задач являются экземплярами класса `TaskEvent`.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_TASK_STARTED` | Задача запущена. Вызывается метод `IgniteCompute.execute()` или другой | Узел, который запускает выполнение задачи |
| `EVT_TASK_REDUCED` | Событие представляет стадию `reduce` в потоке выполнения задачи | Узел, на котором запустилась задача |
| `EVT_TASK_FINISHED` | Выполнение задачи завершено | Узел, на котором запустилась задача |
| `EVT_TASK_FAILED` | Задача не выполнена | Узел, на котором запустилась задача |
| `EVT_TASK_TIMEDOUT` | Время выполнения задачи истекло. Это может произойти, если время настроили с помощью метода `Ignite.compute().withTimeout(…)`. Если время выполнения задачи истекло, все выполняемые задания отменяются и генерируется событие `EVT_TASK_FAILED` | Узел, на котором запустилась задача |
| `EVT_TASK_SESSION_ATTR_SET` | Задание устанавливает атрибут в сессии — подробнее об этом написано в подразделе [MapReduce API](mapreduce_api.md) раздела «Распределенные вычисления» | Узел, на котором выполняется задание |


События выполнения задания являются экземплярами класса `JobEvent`. Они генерируются на разных этапах выполнения задания и связаны с его конкретными экземплярами. Событие содержит информацию о задаче, которая вызвала задание (название, класс и так далее).

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_JOB_MAPPED` | Задание сопоставляется с конкретным узлом. Сопоставление (маппинг) происходит на узле, где запускается задача. Событие генерируется для каждого задания, которое создано на этапе `map` | Узел, который запустил выполнение задачи |
| `EVT_JOB_QUEUED` | Задание добавлено в очередь к узлу, с которым оно было сопоставлено | Узел, на котором запланировано выполнение задания |
| `EVT_JOB_STARTED` | Выполнение задания началось | Узел, на котором выполняется задание |
| `EVT_JOB_FINISHED` | Выполнение задания закончилось (включая случаи отмены заданий) | Узел, на котором выполняется задание |
| `EVT_JOB_RESULTED` | Задание вернуло результат узлу, с которого оно было отправлено | Узел, на котором запустилось выполнение задачи |
| `EVT_JOB_FAILED` | Задание не выполнено. Если настроена стратегия аварийного переключения заданий (по умолчанию), это событие сопровождается `EVT_JOB_FAILED_OVER` | Узел, на котором выполняется задание |
| `EVT_JOB_FAILED_OVER` | Задание не было выполнено и перенеслось на другой узел | Узел, который запустил выполнение задачи |
| `EVT_JOB_TIMEDOUT` | Время выполнения задания истекло | — |
| `EVT_JOB_REJECTED` | Задание отклонено. Это может произойти из-за того, что настроен Collision SPI — подробнее о нем написано в подразделе [«Планирование выполнения заданий»](task_execution_planning.md) раздела «Распределенные вычисления» | Узел, на котором отменено выполнение задания |
| `EVT_JOB_CANCELLED` | Задание отменено | Узел, на котором выполнялось задание |

## События ребалансировки кешей

События ребалансировки кешей (все, кроме `EVT_CACHE_REBALANCE_OBJECT_LOADED` и `EVT_CACHE_REBALANCE_OBJECT_UNLOADED`) являются экземплярами класса `CacheRebalancingEvent`.

Ребалансировка выполняется отдельно для каждого кеша, поэтому каждое событие ребалансировки соответствует определенному кешу. Событие содержит имя кеша.

Процесс перемещения одной партиции кеша с узла A на узел B:

1. Узел A предоставляет партицию (`REBALANCE_PART_SUPPLIED`). Объекты из партиции начинают перемещаться на узел B.
2. Узел B получает данные партиции (`REBALANCE_PART_LOADED`).
3. Узел A удаляет партиции из своего хранилища (`REBALANCE_PART_UNLOADED`).

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CACHE_REBALANCE_STARTED` | Ребалансировка кешей запущена | Все узлы, которые содержат кеш |
| `EVT_CACHE_REBALANCE_STOPPED` | Ребалансировка кешей остановлена | Все узлы, которые содержат кеш |
| `EVT_CACHE_REBALANCE_PART_LOADED` | Партиция кеша загружается на новый узел. Событие генерируется для каждой партиции, которая участвует в ребалансировке кеша | Узел, на который загружается партиция |
| `EVT_CACHE_REBALANCE_PART_UNLOADED` | Партиция кеша удаляется с узла после загрузки в новое место назначения | Узел, который содержал партицию до начала процесса ребалансировки |
| `EVT_CACHE_REBALANCE_OBJECT_LOADED` | Объект перемещается на новый узел в процессе ребалансировки кешей | Узел, на который загружается объект |
| `EVT_CACHE_REBALANCE_OBJECT_UNLOADED` | Объект удаляется с узла после перемещения на новый | Узел, с которого удалился объект |
| `EVT_CACHE_REBALANCE_PART_DATA_LOST` | Партиция, которая должна ребалансироваться, потеряна (например, из-за отказа узла) | — |
| `EVT_CACHE_REBALANCE_PART_SUPPLIED` | Узел предоставляет партицию кеша как часть процесса ребалансировки | Узел, который владеет партицией |

## События транзакций

События транзакций являются экземплярами класса `TransactionStateChangedEvent`. С их помощью можно получить уведомления о разных стадиях выполнения транзакций. Каждое событие содержит объект `Transaction`, с которым оно связано.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_TX_STARTED` | Транзакция запустилась. В транзакционных кешах каждая атомарная операция, которая выполняется вне транзакции, считается транзакцией с одной операцией | Узел, на котором была запущена транзакция |
| `EVT_TX_COMMITTED` | Транзакция завершилась | Узел, на котором была запущена транзакция |
| `EVT_TX_ROLLED_BACK` | Транзакция откатилась | Узел, на котором была выполнена транзакция |
| `EVT_TX_SUSPENDED` | Транзакция приостановилась | Узел, на котором была запущена транзакция |
| `EVT_TX_RESUMED` | Транзакция возобновилась | Узел, на котором была запущена транзакция |

## События снепшотов

Все события снепшотов являются экземплярами класса `SnapshotEvent`.

События снепшотов всегда генерируются на узле, который запустил операцию создания снепшота. Они также связаны с определенным названием операции снепшота. События могут уведомить о состояниях и результатах операций снепшотов, которые можно использовать для дальнейшей обработки пользовательских процедур.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_CLUSTER_SNAPSHOT_STARTED` | Операция снепшота кластера началась | Узел, на котором запустилась операция снепшота |
| `EVT_CLUSTER_SNAPSHOT_FINISHED` | Операция снепшота кластера завершилась. Событие сгенерируется после окончания операции на всех узлах кластера | Узел, на котором завершилась операция снепшота |
| `EVT_CLUSTER_SNAPSHOT_FAILED` | Операция снепшота кластера завершилась неуспешно | Узел, на котором запустилась операция снепшота. В сообщении будет описание ошибки с другого узла. Детали указаны в log-файле |

## События сбоя валидации узла

События запускаются, когда новый узел не может присоединиться к кластеру DataGrid, так как некоторые узлы кластера не смогли его проверить. Валидация включает в себя проверку совместимости конфигурации и состояния между присоединяющимся узлом и остальными узлами кластера. События сбоя валидации узла предоставляют информацию об узле, который пытался присоединиться к кластеру, и причине сбоя проверки.

События, которые относятся к сбою проверки узла, являются экземплярами класса `NodeValidationFailedEvent`.

| Тип события | Описание события | Место, где генерируется событие |
|---|---|---|
| `EVT_NODE_VALIDATION_FAILED` | Валидация узла выполнилась неуспешно | Узел кластера, который проводил валидацию нового узла, пытавшегося присоединиться к кластеру |